
********************************************************************************
ПОНЕДЕЛЬНИК

**************************************************

            Урок 1 (STEP_#01 Виктор 2023-01-02)

    Идея 1: Мы хотим создать несколько листов

    Делаем: (1ч 12м - 1ч 29)
 1) Скопируем несколько раз (раза два) JSX-код в App. Мы видим что у нас
     получилось прекрасное полотно :)
 2) Сделаем в App.tsx еще одну компоненту Todolist, перенесем в нее JSX одного
     листа и в App вставим тег <Todolist/> несколько раз
 3) Создадим в src файл Todolist.txt и перенесем в него Todolist, не забывая
     сделать экспорт и импорт
    Есть !

************

    Идея 2: Мы хотим каждому листу дать свое название

    Задача: Создать название для каждого листа в App, передать его в Todolist и
     в нем вставить в нужное место

    Делаем: (1ч 34м - 1ч 56м)
 1) Мы будем передавать через объект props название листа, поэтому создадим для
     него собственный тип со свойством title (в Todolist.txt над компонентой):

     type TodolistPropsType = {title: string}

 2) Вставим props.title вместо названия (в фигурных скобках)
 3) В App, в каждый тег <Todolist/> вставим атрибут title с соответствующим
     названием
 4) В App создадим переменные для хранения названий листов, типизируем их и
     вставим их в теги как названия листов

    Есть !

**********

    Идея 3: Мы хотим в каждом листе сделать свой список задач, они должны быть
     по разному отмечены

    Задача: Создать данные о списках и отметках в App и передать их в каждый
     Todolist и вставить в нужные места

    Делаем: (2ч 1м - 2ч 14м)
 1) Вначале задумаемся какие данные нам надо передать. Это список из пунктов.
     Каждый пункт состоит из значения checked (отмеченный или нет) и названия
     пункта. В Todolist.tsx сразу сделаем собственный тип для пункта:

     type ItemType = {
         isDone: boolean
         name: string
     }

 2) Также дополним props. У нас там уже есть свойство title и нам надо еще
     передать список из пунктов, сделаем это с помощью массива, элементами
     которого будут наши пункты с типом ItemType:

     type TodolistPropsType = {
         title: string
         list: ItemType[]
     }

 3) Теперь вставим свойства props-объекта в JSX-код, туда, где должны быть
     соответствующие данные (в атрибут checked и тег span), воспользовавшись
     названиями свойств которые мы определили в типах

 4) Осталось в App сделать списки-массивы (объектов - пунктов) arTasks и
     передать их с помощью атрибута (list - согласно TodolistPropsType) в теги
     <Todolist/>

 5) Перед этим в файле Todolist.tsx экспортируем "type ItemType", а в файле
     импортируем его для типизации массивов arTasks (типизировать надо сразу,
     чтоб typescript помогал нам писать код, а не был обузой)

 6) Добавим еще id-шки в каждый пункт, а затем у тегов <li> сделаем атрибут key
     и присвоим ему соответствующие id

    Есть !

**********

    Идея 4: Мы хотим чтобы длина списка устанавливалась автоматически в
    зависимости от массива данных в App, при нулевой длине появлялась надпись,
    что список пустой

    Задача: Наш захардкоженый список (<ul>) надо сделать гибким

    Делаем: (2ч 32м - 2ч 48м)
 1) Пройдемся по массиву props.arList с помощью цикла map, внутрь которого
     положим пункт (один <li> со всем содержимым). Сделаем переменную listItems
     в которую будет присваиваться новый массив уже с пунктами

 2) Теперь сделаем условие с помощью тернарного оператора, если длина массива
     props.arList > 0 (т е условие истинно), то в listItems будет записываться
     наш список, а если нет, то строка "Empty list" в теге <span>
     
 3) Вставим {listItems} в <ul>

    Есть !

************************************************

          Урок 2 (STEP_#02 Виктор 2023-01-09)

    Идея 5: Мы хотим добавить кнопки в каждый пункт списка, при нажатии на
     которые этот пункт будет удаляться

    Задача: Нужно добавить в кнопки обработчики события 'click'. При нажатии на
     данную кнопку обработчик видит id этого пункта и удаляет его из массива
     arTasks в App. Далее мы используем хук useState, чтобы запомнить новый
     массив arTasks (уже с удаленным пунктом) и перезапустить App для
     перерисовки

    Делаем: (0ч 25м - 1ч 15м)
 1) Оставляем один Todolist для удобства и делаем кнопки в каждом <li/> т е в
     <li> в цикле map

 2) В кнопке создаем атрибут onClick и присваиваем ему анонимную стрелочную
     функцию внутри которой вызываем alert c id данного пункта, теперь при клике
      на кнопку alert выводит номер пункта

 3) Создадим функцию removeItem в цикле map выше return пусть эта функция
     вызывает alert(elArList.id) внутри себя. Присвоим onClick = { removeItem },
     и у нас получилось, что мы вынесли функцию за пределы JSX. И кнопка также
     работает

 4) Создадим в App такую функцию и вызовем ее:

     const removeTask = (idTask: number) => {
             arTasks = arTasks.filter((task) => task.id != idTask)
             console.log(arTasks)
     }
     removeTask(2)

     И скобки вокруг параметра колбека можно опустить. Получается, что эта
        функция убирает из массива arTasks тот объект, id которого мы передаем
        ей

 5) Опрокинем removeTask в Todolist, чтобы подключить ее к кнопкам. Возвращаемся
     к объекту типа пропсов и напишем туда еще одно свойство-функцию:

     type TodolistPropsType = {
        title: string
        arList: ItemType[]
        removeItem: (idTask: number) => void
     }

 6) Теперь в App в <Todolist/> добавим атрибут removeItem = {removeTask}
 7) В Todolist мы делали функцию removeItem, которая показывала id пункта:

    const removeItem = () => alert(elArList.id)

    осталось заменить alert на props.removeItem:

    const removeItem = () => props.removeItem(elArList.id)

    Теперь наши кнопки работают, в том смысле, что удаляют элементы массива
    данных arTasks - это видно в консоли, но сами пункты остаются на месте т к
    не происходит перерисовка по новому массиву. Для полноценного решения нам
    нужен хук useState !

 8) Пишем useState (типизируем его) и в качестве параметра даем ему наш массив
     arTasks. Хук возвращает массив из двух значений - текущий массив (текущий
     стейт) и функцию для изменения текущего массива. Эти значения мы используем
      в функции removeTask:

    let [arTasks, setArTasks] = useState<Array<ItemType>>([
            {id: 1, isDone: true, name: 'HTML&CSS'},
            {id: 2, isDone: false, name: 'TS'},
            {id: 3, isDone: false, name: 'React'},
    ])

    const removeTask = (idTask: number) => {
        setArTasks(arTasks.filter(task => task.id !== idTask))
    }

    Есть !

**********



